---
title: "ESM 263: Homework 3"
author: "Linus Blomqvist"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r load_packages, include = FALSE}
pacman::p_load(sf, raster, tmap, tidyverse, units, scales)
```

# Vector approach

The R package for working with vector data is `sf`. Functions associated with this package typically start with st_.

In the vector approach, I will use these layers to create a set of new features (multipolygons) that represent suitable areas by each criterion. The intersection of all these features is the set of suitable areas for wind development.

## Read in data
We're given three data files for this assignment: `basemaps.gpkg`, `inputs.gpkg`, and `Wind2002_which_one`. GeoPackage files can contain multiple layers so first I'll check what's in basemaps:

```{r basemaps_layers}
st_layers("HW3/data_hw3/basemaps.gpkg")$name
```

We won't need these for the analysis so I won't load them at this point.

Let's see what's in `inputs.gpkg`:

```{r}
# Create a list of layer names and display them
input_layers <- st_layers("HW3/data_hw3/inputs.gpkg")$name
input_layers
```

We could read these into a single `sf` object using a for loop, but in this case I'll keep them as separate objects, so I'll just read them in one by one. The `read_sf` function will automatically recognize the format of the file to be read in, so we just need to specify the layer (using the list of layer names created in the previous code chunk).

```{r}
airports <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[1])
roads <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[2])
fireLRA <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[3])
parcels <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[4])
fireSRA <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[5])
county <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[6])
urban <- read_sf("HW3/data_hw3/inputs.gpkg", layer = input_layers[7])
```

The `roads` layer (along with all the other layers) has the following CRS:
```{r}
st_crs(roads)$input
```

Finally, we read in the wind raster data. For this we need to use the `raster` function from the `raster` package. R also has a newer package, `stars`, that handles raster data, but `raster` will do a perfectly fine job for the purposes of this assignment.

```{r}
wind_raster <- raster("HW3/data_hw3/Wind2002/Wind2002.tif")
```

## Wind

We need to convert this raster layer to polygons, but first let's see what it looks like. For very simple plots, `raster` can use the `plot()` command from base R.

```{r}
tm_shape(wind_raster) +
  tm_raster()
```

One thing to note about the wind data is that it is a categorical variable, with seven wind classes (1, 2, ..., 7). We see this from looking at the unique values in the data:

```{r}
unique(getValues(wind_raster))
```

I now convert the raster data to polygons. A couple of things to note here. I use the function `rasterToPolygons` with the option to dissolve, which gives me just one multipolygon per wind speed class. I then use `st_as_sf` to convert it to an `sf` object. I'm also going to rename the wind variable.

```{r wind_raster_to_vector, message = FALSE}
wind_sf <- st_as_sf(rasterToPolygons(wind_raster, dissolve = TRUE))
colnames(wind_sf)[1] <- "wind_speed"
```

It doesn't hurt to check that this object has the same CRS as the ones previously loaded:
```{r}
st_crs(wind_sf) == st_crs(roads)
```

Now we can map this:

```{r}
tm_shape(wind_sf) +
  tm_fill(col = "wind_speed") +
  tm_shape(county) +
  tm_borders()
```
This looks a lot like the map of the raster data, so that's good.

Since we require wind speeds above 6.4 m/s, and there's only one wind class that meets that requirement, the suitability layer here is simply `wind_sf[7,]`. To remember more easily I'll call it `wind_suitable`.

```{r}
wind_suitable <- wind_sf[7,]
```


## Roads
This requirement states that sites need to be within 7.5 km of a major road. The `roads` data comes in the form of of MULTILINESTRING (you can check this with `st_geometry_type(roads, by_geometry = FALSE))`, so we can just make a buffer around those lines. We can see the unit of measurement by, for example, getting the distance of the first linestring:

```{r}
st_length(roads[1,])
```

I'll also clip the roads buffer to the county so it doesn't unnecessarily extend outside it.
```{r}
road_suitable <- st_union(st_buffer(roads, dist = 7500))
road_suitable <- st_intersection(road_suitable, county)
```

We can plot this to make sure it looks reasonable.

```{r}
tm_shape(road_suitable) +
  tm_polygons(col = "lightgreen", alpha = 0.5) +
  tm_shape(county) +
  tm_borders(col = "black", lwd = 2) +
  tm_layout(main.title = "7.5 bm buffer around major roads")
```

## Airports

We need to identify areas that are more than 7.5 km from an airport. This is equivalent to being inside the county but outside an airport buffer. First let's look at the airport data.

```{r}
tm_shape(county) +
  tm_borders(col = "black", lwd = 2) +
  tm_shape(airports) +
  tm_polygons(col = "red")
```
We can see Santa Barbara Airport towards the southeast, for example. Now we'll make a buffer, and while it doesn't really matter, we might as well dissolve it into a single multipolygon.

```{r}
airport_buffer <- st_union(st_buffer(airports, dist = 7500))
```

The operation we need to find suitable areas here is `st_difference`, which, with arguments $x$ and $y$ gives us the area that is in $y$ but not in $x$.

```{r}
airports_suitable <- st_difference(county, airport_buffer)
```

We can plot this to make sure we got it right:

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(airports_suitable) +
  tm_polygons(col = "lightgreen")
```

## Urban area

Similar to the above, we need to identify areas not within 1 mile of an existing urban area. Let's look at the map for urban areas.

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(urban) +
  tm_polygons(col = "red")
```
As for airports, we make a buffer and then take the difference between the buffer and the county.

```{r}
urban_buffer <- st_union(st_buffer(urban, dist = 1609)) # 1609 meters in a mile
urban_suitable <- st_difference(county, urban_buffer)
```

And plot it:

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(urban_suitable) +
  tm_polygons(col = "lightgreen")
```
## Fire

It wasn't very clear to me what to do with the fire layer so let's look at it and see what it might mean. The data are already filtered to only include areas with very high fire risk, which presumably we'll exclude from the suitable areas.

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(fireLRA) +
  tm_polygons(col = "red") +
  tm_layout(main.title = "Fire LRA")
```

Since we want to identify areas that are suitable, I'll take the difference between the fire risk zones and the county.

```{r}
fireLRA_suitable <- st_difference(county, fireLRA)
```

Plot to make sure SOMETHING WRONG HERE

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(fireLRA_suitable) +
  tm_polygons(col = "lightgreen") +
  tm_layout(main.title = "Fire LRA suitable")
```


For fire SRA, I'll filter for features with `HAZ_CODE = 3`.
```{r}
fireSRA_haz3 <- filter(fireSRA, HAZ_CODE == 3)
tm_shape(county) +
  tm_borders() +
  tm_shape(fireSRA_haz3) +
  tm_polygons(col = "red") +
  tm_layout(main.title = "Fire SRA")
```
This is a lot of area to exclude, so at this point I suspect the area suitable for wind is actually going to be relatively small. Again, take the difference.

```{r}
fireSRA_suitable <- st_difference(county, fireSRA_haz3)
```

Let's plot this to double check. SOMETHING WRONG HERE TOO

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(fireSRA_suitable) +
  tm_polygons(col = "lightgreen") +
  tm_layout(main.title = "Fire SRA suitable")
```

Now we have six layers where wind is suitable by corresponding criteria. To find out where wind is suitable by all criteria, we find the intersection of all these layers.

```{r}
suitable_all <- st_intersection(wind_suitable, road_suitable, airports_suitable,
                                urban_suitable, fireLRA_suitable, fireSRA_suitable)
```

Let's plot this.

```{r}
tm_shape(county) +
  tm_borders() +
  tm_shape(suitable_all) +
  tm_fill(col = "green")
```
That's really not a lot of space to build on! Now we have one more thing to do, based on this part of the assignment:

* The Energy Division wants a ranked list of 10 potential sites, each with at least 4 contiguous hectares

I take this to mean that each suitable polygon has to be at least 4 hectares. What I have in my `suitable_all` layer is a multipolygon with only one layer, so I'll transform ("cast") this into separate polygons.

```{r}
suitable_all <- st_cast(suitable_all, "POLYGON")
```

Now let's calculate the area for each of these polygons, and create a new object with only those with the required area.

```{r}
suitable_all$area <- drop_units(st_area(suitable_all))
suitable_4_ha <- filter(suitable_all, area >= 40000)
```

We now have a set of `r nrow(suitable_4_ha)` polygons that meet all the criteria. The Energy Division wants just 10, and ranked. Since all criteria are binary, I don't know how to rank them, so I'll just take the first ten.

```{r}
head(suitable_4_ha, 10)
```

