---
title: "ESM 263 HW2"
author: "Linus Blomqvist"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages, echo = FALSE, message = FALSE}
library(knitr)
library(tidyverse)
library(sf)
library(units)
library(tmap)
library(magrittr)
library(bookdown)
library(scales)
library(tictoc)
library(RColorBrewer)
```

# Loading and exploring data

Check what layers are in the basemap.
```{r}
st_layers("HW2/data_hw2/basemap.gpkg")$name
```

I'll include code for reading in the first layer; for the other layers, the code will not show (but it's there under the hood).

```{r read_data, message=TRUE, warning=FALSE}
california <- st_read("HW2/data_hw2/basemap.gpkg", layer = "California")
```
For this and any other layers we can do a little exploring. For example, we can check the variable names:

```{r}
names(california)
```

Note that in an `sf` object, there's always a column at the end called `geom`; this contains all the spatial information.

We can also do a quick plot to see what we have. Looks like counties.

```{r}
tm_shape(st_geometry(california)) +
  tm_polygons()
```

```{r read2, include = FALSE}

# Reading the rest of the layers
cities <- st_read("HW2/data_hw2/basemap.gpkg", layer = "Cities")
county <- st_read("HW2/data_hw2/basemap.gpkg", layer = "County")
ROI <- st_read("HW2/data_hw2/basemap.gpkg", layer = "ROI")
streets <- st_read("HW2/data_hw2/basemap.gpkg", layer = "streets")
```

I'm also interested to see the ROI (region of interest). In the html version of this file, you'll be able to see this against a base layer and zoom around etc, as the map view mode is interactive. We can see that we're only interested in what looks like the downtown area including the harbor.

```{r}
tmap_mode("view")
tm_shape(st_geometry(ROI)) +
  tm_borders()
```

There's only one layer, "`r st_layers("HW2/data_hw2/parcels.gpkg")$name`", in the parcels file so we'll read that in. We can check the variables names here too.

```{r}
parcels <- st_read("HW2/data_hw2/parcels.gpkg")
names(parcels)
```
The variable we're interested in is `NET_AV`, so we can check what that looks like (on a log 10 scale to make it easier to read).

```{r hist, message = FALSE, warning = FALSE}
ggplot(parcels) +
  geom_histogram(aes(x = NET_AV)) +
  scale_x_log10() +
  xlab("Net assessed value")
```

Seems like most parcels are valued at just under a million dollars, but some are worth tens of millions of dollars.

I'll write a script to make the reading in of the `r length(st_layers("HW2/data_hw2/inundation_scenarios.gpkg")$name)` inundation layers more efficient. I'll also save those object in a single list.

```{r read2}

# Get a list of the layer names
inund_layers <- st_layers("HW2/data_hw2/inundation_scenarios.gpkg")$name

# Read in all individual layers into a single list
inund <- list() # make empty list
for (i in inund_layers) { # loop over each layer
  inund[[i]] <- st_read("HW2/data_hw2/inundation_scenarios.gpkg", layer = i)
}

# Concatenate "inund scenario" with the layer/scenario number
scenario_names <- c()
for (i in 1:length(inund_layers)) {
  scenario_names[i] <- str_c("scenario", inund_layers[i], collapse = "")
}

# Now rename the elements of the list
names(inund) <- scenario_names
```

Now we can access a scenario like 01 with `inund$scenario01`. Let's look at one of these scenarios:

```{r}
tm_shape(st_geometry(inund$scenario10)) +
    tm_fill(col = "lightblue")
```

Seems like this represents current land area that would be inundated under the scenario in question.

# Spatial join
What we want here is the total value of all parcels that fall within the inundated area for each scenario.

```{r}

```

